{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { MAZE, GAME_STATES, INITIAL_GHOSTS, INITIAL_PLAYER_POSITION } from '../constants/gameConstants';\nexport const useGameLogic = () => {\n  _s();\n  const [shiroPosition, setShiroPosition] = useState(INITIAL_PLAYER_POSITION);\n  const [maze, setMaze] = useState(MAZE);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(parseInt(localStorage.getItem('shiroNekoHighScore') || '0'));\n  const [lives, setLives] = useState(3);\n  const [level, setLevel] = useState(1);\n  const [gameState, setGameState] = useState(GAME_STATES.READY);\n  const [direction, setDirection] = useState({\n    x: 0,\n    y: 0\n  });\n  const [powerMode, setPowerMode] = useState(false);\n  const [powerModeTimer, setPowerModeTimer] = useState(0);\n  const [gameTime, setGameTime] = useState(0);\n  const [ghosts, setGhosts] = useState(INITIAL_GHOSTS);\n  const [totalDots, setTotalDots] = useState(0);\n  const [dotsEaten, setDotsEaten] = useState(0);\n  const gameLoopRef = useRef();\n  const powerModeRef = useRef();\n  const ghostLoopRef = useRef();\n\n  // Inicializar puntos totales\n  useEffect(() => {\n    const dots = MAZE.flat().filter(cell => cell === 2 || cell === 3).length;\n    setTotalDots(dots);\n  }, []);\n\n  // Verificar colisiones con fantasmas\n  const checkGhostCollision = useCallback(position => {\n    return ghosts.some(ghost => ghost.x === position.x && ghost.y === position.y);\n  }, [ghosts]);\n\n  // Mover fantasmas\n  const moveGhosts = useCallback(() => {\n    if (gameState !== GAME_STATES.PLAYING) return;\n    setGhosts(prevGhosts => prevGhosts.map(ghost => {\n      const possibleDirections = [{\n        x: 0,\n        y: -1\n      },\n      // arriba\n      {\n        x: 0,\n        y: 1\n      },\n      // abajo\n      {\n        x: -1,\n        y: 0\n      },\n      // izquierda\n      {\n        x: 1,\n        y: 0\n      } // derecha\n      ];\n\n      // Filtrar direcciones válidas (no paredes)\n      const validDirections = possibleDirections.filter(dir => {\n        const newX = ghost.x + dir.x;\n        const newY = ghost.y + dir.y;\n        return newX >= 0 && newX < 20 && newY >= 0 && newY < 20 && maze[newY][newX] !== 1;\n      });\n      if (validDirections.length === 0) return ghost;\n\n      // Elegir dirección basada en el modo del fantasma\n      let chosenDirection;\n      if (ghost.mode === 'frightened') {\n        // Modo asustado: movimiento aleatorio\n        chosenDirection = validDirections[Math.floor(Math.random() * validDirections.length)];\n      } else {\n        // Modo persecución: intentar acercarse al jugador\n        const playerDistance = dir => {\n          const newX = ghost.x + dir.x;\n          const newY = ghost.y + dir.y;\n          return Math.abs(newX - shiroPosition.x) + Math.abs(newY - shiroPosition.y);\n        };\n\n        // Encontrar la dirección que más acerca al fantasma al jugador\n        chosenDirection = validDirections.reduce((best, current) => playerDistance(current) < playerDistance(best) ? current : best);\n      }\n      return {\n        ...ghost,\n        x: ghost.x + chosenDirection.x,\n        y: ghost.y + chosenDirection.y,\n        direction: chosenDirection\n      };\n    }));\n  }, [gameState, maze, shiroPosition]);\n\n  // Mover Shiro Neko\n  const moveShiro = useCallback(newDirection => {\n    if (gameState !== GAME_STATES.PLAYING) return;\n    setShiroPosition(prev => {\n      const newX = prev.x + newDirection.x;\n      const newY = prev.y + newDirection.y;\n      if (newX < 0 || newX >= 20 || newY < 0 || newY >= 20) return prev;\n      if (maze[newY][newX] === 1) return prev;\n      const newPosition = {\n        x: newX,\n        y: newY\n      };\n\n      // Verificar colisión con fantasmas\n      if (checkGhostCollision(newPosition)) {\n        if (powerMode) {\n          setScore(s => s + 200);\n          setGhosts(prevGhosts => prevGhosts.map(ghost => ghost.x === newX && ghost.y === newY ? {\n            ...ghost,\n            x: 9,\n            y: 9,\n            mode: 'frightened'\n          } : ghost));\n        } else {\n          setLives(l => l - 1);\n          if (lives <= 1) {\n            if (score > highScore) {\n              setHighScore(score);\n              localStorage.setItem('shiroNekoHighScore', score.toString());\n            }\n            setGameState(GAME_STATES.GAME_OVER);\n          } else {\n            setShiroPosition(INITIAL_PLAYER_POSITION);\n            setGhosts(INITIAL_GHOSTS);\n          }\n          return prev;\n        }\n      }\n\n      // Comer comida\n      if (maze[newY][newX] === 2 || maze[newY][newX] === 3) {\n        const isPowerPellet = maze[newY][newX] === 3;\n        const points = isPowerPellet ? 50 : 10;\n        setScore(s => s + points);\n        setDotsEaten(d => d + 1);\n        if (isPowerPellet) {\n          setPowerMode(true);\n          setPowerModeTimer(8000);\n          setGhosts(prevGhosts => prevGhosts.map(ghost => ({\n            ...ghost,\n            mode: 'frightened'\n          })));\n        }\n        setMaze(prevMaze => {\n          const newMaze = [...prevMaze];\n          newMaze[newY] = [...newMaze[newY]];\n          newMaze[newY][newX] = 0;\n          return newMaze;\n        });\n      }\n      return newPosition;\n    });\n  }, [gameState, maze, ghosts, powerMode, lives, checkGhostCollision, score, highScore]);\n\n  // Reiniciar juego\n  const resetGame = useCallback(() => {\n    setShiroPosition(INITIAL_PLAYER_POSITION);\n    setMaze(MAZE);\n    setScore(0);\n    setLives(3);\n    setLevel(1);\n    setGameState(GAME_STATES.READY);\n    setDirection({\n      x: 0,\n      y: 0\n    });\n    setPowerMode(false);\n    setPowerModeTimer(0);\n    setDotsEaten(0);\n    setGameTime(0);\n    setGhosts(INITIAL_GHOSTS);\n  }, []);\n  return {\n    // Estado del juego\n    shiroPosition,\n    maze,\n    score,\n    highScore,\n    lives,\n    level,\n    gameState,\n    direction,\n    powerMode,\n    powerModeTimer,\n    gameTime,\n    ghosts,\n    totalDots,\n    dotsEaten,\n    // Referencias\n    gameLoopRef,\n    powerModeRef,\n    ghostLoopRef,\n    // Funciones\n    setGameState,\n    setDirection,\n    moveShiro,\n    moveGhosts,\n    resetGame,\n    checkGhostCollision,\n    setGhosts\n  };\n};\n_s(useGameLogic, \"5GA9ssRR0tniFYdo0v7/Ir9Sj0A=\");","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","MAZE","GAME_STATES","INITIAL_GHOSTS","INITIAL_PLAYER_POSITION","useGameLogic","_s","shiroPosition","setShiroPosition","maze","setMaze","score","setScore","highScore","setHighScore","parseInt","localStorage","getItem","lives","setLives","level","setLevel","gameState","setGameState","READY","direction","setDirection","x","y","powerMode","setPowerMode","powerModeTimer","setPowerModeTimer","gameTime","setGameTime","ghosts","setGhosts","totalDots","setTotalDots","dotsEaten","setDotsEaten","gameLoopRef","powerModeRef","ghostLoopRef","dots","flat","filter","cell","length","checkGhostCollision","position","some","ghost","moveGhosts","PLAYING","prevGhosts","map","possibleDirections","validDirections","dir","newX","newY","chosenDirection","mode","Math","floor","random","playerDistance","abs","reduce","best","current","moveShiro","newDirection","prev","newPosition","s","l","setItem","toString","GAME_OVER","isPowerPellet","points","d","prevMaze","newMaze","resetGame"],"sources":["C:/Users/usuario/Downloads/juego/src/hooks/useGameLogic.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { MAZE, GAME_STATES, INITIAL_GHOSTS, INITIAL_PLAYER_POSITION } from '../constants/gameConstants';\n\nexport const useGameLogic = () => {\n  const [shiroPosition, setShiroPosition] = useState(INITIAL_PLAYER_POSITION);\n  const [maze, setMaze] = useState(MAZE);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(parseInt(localStorage.getItem('shiroNekoHighScore') || '0'));\n  const [lives, setLives] = useState(3);\n  const [level, setLevel] = useState(1);\n  const [gameState, setGameState] = useState(GAME_STATES.READY);\n  const [direction, setDirection] = useState({ x: 0, y: 0 });\n  const [powerMode, setPowerMode] = useState(false);\n  const [powerModeTimer, setPowerModeTimer] = useState(0);\n  const [gameTime, setGameTime] = useState(0);\n  const [ghosts, setGhosts] = useState(INITIAL_GHOSTS);\n  const [totalDots, setTotalDots] = useState(0);\n  const [dotsEaten, setDotsEaten] = useState(0);\n  \n  const gameLoopRef = useRef();\n  const powerModeRef = useRef();\n  const ghostLoopRef = useRef();\n\n  // Inicializar puntos totales\n  useEffect(() => {\n    const dots = MAZE.flat().filter(cell => cell === 2 || cell === 3).length;\n    setTotalDots(dots);\n  }, []);\n\n  // Verificar colisiones con fantasmas\n  const checkGhostCollision = useCallback((position) => {\n    return ghosts.some(ghost => ghost.x === position.x && ghost.y === position.y);\n  }, [ghosts]);\n\n  // Mover fantasmas\n  const moveGhosts = useCallback(() => {\n    if (gameState !== GAME_STATES.PLAYING) return;\n    \n    setGhosts(prevGhosts => \n      prevGhosts.map(ghost => {\n        const possibleDirections = [\n          { x: 0, y: -1 }, // arriba\n          { x: 0, y: 1 },  // abajo\n          { x: -1, y: 0 }, // izquierda\n          { x: 1, y: 0 }   // derecha\n        ];\n        \n        // Filtrar direcciones válidas (no paredes)\n        const validDirections = possibleDirections.filter(dir => {\n          const newX = ghost.x + dir.x;\n          const newY = ghost.y + dir.y;\n          return newX >= 0 && newX < 20 && newY >= 0 && newY < 20 && maze[newY][newX] !== 1;\n        });\n        \n        if (validDirections.length === 0) return ghost;\n        \n        // Elegir dirección basada en el modo del fantasma\n        let chosenDirection;\n        if (ghost.mode === 'frightened') {\n          // Modo asustado: movimiento aleatorio\n          chosenDirection = validDirections[Math.floor(Math.random() * validDirections.length)];\n        } else {\n          // Modo persecución: intentar acercarse al jugador\n          const playerDistance = (dir) => {\n            const newX = ghost.x + dir.x;\n            const newY = ghost.y + dir.y;\n            return Math.abs(newX - shiroPosition.x) + Math.abs(newY - shiroPosition.y);\n          };\n          \n          // Encontrar la dirección que más acerca al fantasma al jugador\n          chosenDirection = validDirections.reduce((best, current) => \n            playerDistance(current) < playerDistance(best) ? current : best\n          );\n        }\n        \n        return {\n          ...ghost,\n          x: ghost.x + chosenDirection.x,\n          y: ghost.y + chosenDirection.y,\n          direction: chosenDirection\n        };\n      })\n    );\n  }, [gameState, maze, shiroPosition]);\n\n  // Mover Shiro Neko\n  const moveShiro = useCallback((newDirection) => {\n    if (gameState !== GAME_STATES.PLAYING) return;\n    \n    setShiroPosition(prev => {\n      const newX = prev.x + newDirection.x;\n      const newY = prev.y + newDirection.y;\n      \n      if (newX < 0 || newX >= 20 || newY < 0 || newY >= 20) return prev;\n      if (maze[newY][newX] === 1) return prev;\n      \n      const newPosition = { x: newX, y: newY };\n      \n      // Verificar colisión con fantasmas\n      if (checkGhostCollision(newPosition)) {\n        if (powerMode) {\n          setScore(s => s + 200);\n          setGhosts(prevGhosts => \n            prevGhosts.map(ghost => \n              ghost.x === newX && ghost.y === newY \n                ? { ...ghost, x: 9, y: 9, mode: 'frightened' }\n                : ghost\n            )\n          );\n        } else {\n          setLives(l => l - 1);\n          if (lives <= 1) {\n            if (score > highScore) {\n              setHighScore(score);\n              localStorage.setItem('shiroNekoHighScore', score.toString());\n            }\n            setGameState(GAME_STATES.GAME_OVER);\n          } else {\n            setShiroPosition(INITIAL_PLAYER_POSITION);\n            setGhosts(INITIAL_GHOSTS);\n          }\n          return prev;\n        }\n      }\n      \n      // Comer comida\n      if (maze[newY][newX] === 2 || maze[newY][newX] === 3) {\n        const isPowerPellet = maze[newY][newX] === 3;\n        const points = isPowerPellet ? 50 : 10;\n        setScore(s => s + points);\n        setDotsEaten(d => d + 1);\n        \n        if (isPowerPellet) {\n          setPowerMode(true);\n          setPowerModeTimer(8000);\n          setGhosts(prevGhosts => \n            prevGhosts.map(ghost => ({ ...ghost, mode: 'frightened' }))\n          );\n        }\n        \n        setMaze(prevMaze => {\n          const newMaze = [...prevMaze];\n          newMaze[newY] = [...newMaze[newY]];\n          newMaze[newY][newX] = 0;\n          return newMaze;\n        });\n      }\n      \n      return newPosition;\n    });\n  }, [gameState, maze, ghosts, powerMode, lives, checkGhostCollision, score, highScore]);\n\n  // Reiniciar juego\n  const resetGame = useCallback(() => {\n    setShiroPosition(INITIAL_PLAYER_POSITION);\n    setMaze(MAZE);\n    setScore(0);\n    setLives(3);\n    setLevel(1);\n    setGameState(GAME_STATES.READY);\n    setDirection({ x: 0, y: 0 });\n    setPowerMode(false);\n    setPowerModeTimer(0);\n    setDotsEaten(0);\n    setGameTime(0);\n    setGhosts(INITIAL_GHOSTS);\n  }, []);\n\n  return {\n    // Estado del juego\n    shiroPosition,\n    maze,\n    score,\n    highScore,\n    lives,\n    level,\n    gameState,\n    direction,\n    powerMode,\n    powerModeTimer,\n    gameTime,\n    ghosts,\n    totalDots,\n    dotsEaten,\n    \n    // Referencias\n    gameLoopRef,\n    powerModeRef,\n    ghostLoopRef,\n    \n    // Funciones\n    setGameState,\n    setDirection,\n    moveShiro,\n    moveGhosts,\n    resetGame,\n    checkGhostCollision,\n    setGhosts\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}